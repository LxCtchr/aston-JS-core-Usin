# 1. OPTIONS
Это HTTP-метод, который используется для описания параметров соединения с сервером.
## Свойства
- Сам запрос не имеет тела.
- Успешный ответ будет иметь тело.
- Запрос является _безопасным_.
- Запрос является _идемпотентным_.
## Приминение
- Данный метод необходим для междоменного взаимодействия в сети, в соответсвии с политикой CORS, а также для определения разрешённых сервером методов запроса.
- Данный метод направляет предварительный запрос для того, чтобы сервер ответил возможно ли в дальнейшем отправлять другие запросы.
- В составе предварительного запроса будут находиться:
  - _Access-Control-Request-Method_ заголовок уведомляет сервер в составе предварительного запроса о том что, запрос OPTIONS будет отправляться на сервер вместе с POST запросом.
  - _Access-Control-Request-Headers_ заголовок уведомляет сервер о том, что при отправке фактического запроса, он будет отправлен с помощью пользовательских заголовков X-PINGOTHER и Content-Type. В этом случае сервер имеет возможность определять возможно ли принять запрос с такими параметрами.
- Ответ сервера будет содержать параметр _Access-Control-Allow-Methods_ и сообщит, что POST, GET, и OPTIONS методы являются приемлемыми для данного ресурса.
## Синтаксис
```
OPTIONS / HTTP/1.1
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type
```
# 2. HTTP 3.0
HTTP/3 — готовящаяся к стандартизации версия протокола HTTP.

Первоначальное название HTTP/3 — HTTP-over-QUIC.

Использует новый транспортный протокол QUIC, и за счёт этого передаёт данные быстрее.
## QUIC
QUIC (Quick UDP Internet Connection) — транспортный протокол, основанный на UDP. Был разработан Google в 2012 году.

QUIC решает проблемы протоколов TCP и UDP (HTTP/1 и HTTP/2 используют TCP):
- Сокращает время на установку соединения.
- Берёт от UDP высокую скорость передачи, но при этом контролирует целостность пакетов.
- Может передавать несколько пакетов параллельно, что тоже ускоряет их доставку.

HTTP/3 использует QUIC на транспортном уровне и уровне безопасности. QUIC заменяет TCP и TLS.

QUIC включает в себя TLS 1.3, обеспечивает безопасное зашифрованное соединение, но при этом не требует такого количества «рукопожатий».

Помимо QUIC, HTTP/3 отличается от HTTP/2 тем, что имеет другой алгоритм сжатия заголовков и исключает некоторые функции (например, мультиплексирование), так как их уже содержит QUIC.

HTTP/3 лучше реализовывает мультиплексирование. Если в HTTP/2 при потере TCP-пакета вся передача данных останавливалась до восстановления пропажи, то в HTTP/3 информация продолжает передаваться.

Пока HTTP/3 не стандартизован, но его уже поддерживают многие сервисы и браузеры.
# 3. Способы отмены запроса
## AbortController()
Встроенный объект AbortController можно использовать для отмены fetch и других асинхронных задач.
### Создание контроллера
```
const controller = new AbortController();
```
Он имеет единственный метод abort() и единственное свойство signal.

При вызове abort():
- Генерируется событие с именем abort на объекте controller.signal
- Свойство controller.signal.aborted становится равным true.

Узнать о вызове abort(), можно с помощью обработчика на controller.signal.

Можно передать свойство signal опцией в метод fetch:
```
const controller = new AbortController();
fetch(URL, {
  signal: controller.signal
});
```
Метод fetch умеет работать с AbortController, он слушает событие abort на signal.

Чтобы прервать выполнение fetch, необходимо вызовать **controller.abort()**:

Далее fetch получает событие из signal и прерывает запрос.

*AbortController существует не только для fetch, это универсальный объект для отмены асинхронных задач, в fetch встроена интеграция с ним.*

## XMLHttpRequest.abort()
Метод XMLHttpRequest.abort() прерывает уже отправленный запрос.
### Синтаксис
```
const xhr = new XMLHttpRequest(),
  method = "GET",
  url = "https://developer.mozilla.org/";
xhr.open(method, url, true);
xhr.send();
xhr.abort();
```
Когда запрос прерывается, то его свойство readyState устанавливается в UNSENT (0) - не отпарвлен, а status в 0.
# 4. По 2 примера создания примитивных значений приведены в файле [_createPrimitive.js_](https://github.com/LxCtchr/aston-JS-core-Usin/blob/master/createPrimitive.js) в данном репозитории
# 5. Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError?
Данная ошибка возникает из-за Temporal Dead Zone - Временная мертвая зона.

TDZ: термин для описания состояния, когда переменные недоступны. Они находятся в области видимости, но не объявлены.

Объявления let и const имеют блочную область видимости, что означает, что они доступны только в пределах фигурных скобок - { }, окружающих их.

Переменные let и const существуют в TDZ с начала их объемлющей области видимости до момента их объявления.

Можно также сказать, что переменные существуют в TDZ с момента их привязки (когда переменная привязывается к области видимости, внутри которой она находится) до момента ее объявления (когда для этой переменной в памяти резервируется имя).

### Примеры
```
{
  // Это была бы мертвая зона для переменной status!
  // Это была бы мертвая зона для переменной status!
  let status = true; // Больше не мертвая зона
  console.log(status);
}
```
Если бы мы обратились к переменной status раньше, чем она была объявлена, это вызвало бы ошибку ReferenceError. Из-за TDZ.
```
{
  console.log(test2)
  let test2 = 13;
}
```
В данном случае произойдет ошибка: *Uncaught ReferenceError: Cannot access 'test2' before initialization*
# 6. Решение задачек приведены в файле [_tasks.js_](https://github.com/LxCtchr/aston-JS-core-Usin/blob/master/tasks.js) в данном репозитории
